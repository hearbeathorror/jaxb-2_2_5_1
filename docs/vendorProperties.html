<html>
  <head>
    <caption>Vendor Properties</caption>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" type="text/css" href="style/default.css"/>
  </head>

  <body>
    <header />

    <h2>Marshaller Properties</h2>
  
    <p>
    The JAXB RI provides additional Marshaller properties that are not defined 
    by the JAXB specification. These properties allow you to better control the 
    marshalling process, but they only work with the JAXB RI; they may not work  
    with other JAXB providers.</p>
  
	<h3>Index of Marshaller Properties</h3>
	<ul>
	  <li><a href="#prefixmapper">Namespace Prefix Mapping</a></li>
	  <li><a href="#indent">Indentation</a></li>
	  <li><a href="#charescape">Character Escaping Control</a></li>
	  <li><a href="#xmldecl">XML Declaration Control</a></li>
	  <!--li><a href=""></a> - </li-->
	</ul>

	<a name="prefixmapper"></a>
    <h3>Namespace Prefix Mapping</h3>
    <table class=property summary="">
  	  <tr><td>
  		<b>Property name:</b>
  	  </td><td>
  		<tt>com.sun.xml.bind.namespacePrefixMapper</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Type:</b>
  	  </td><td>
  		<tt>com.sun.xml.bind.marshaller.NamespacePrefixMapper</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Default value:</b>
  	  </td><td>
  		null
  	  </td></tr>
    </table>
    
    <p>The JAXB RI provides a mechanism for users to control declarations of namespace URIs and what prefixes they will be bound to. This is the general procedure:</p>
    
    <ol>
      <li>The application developer provides an implementation of 
          <tt>com.sun.xml.bind.marshaller.NamespacePrefixMapper</tt>.</li>
      <li>This class is then set on the marshaller via the RI specific property
          <tt>com.sun.xml.bind.namespacePrefixMapper</tt>.</li>
      <li>Each time the marshaller sees a URI, it performs a callback on the 
          mapper: 
          "What prefix do you want for this namespace URI?"</li>
      <li>If the mapper returns something, the marshaller will try to use it.</li>
    </ol>
    
    <p>The <tt>com.sun.xml.bind.marshaller.NamespacePrefixMapper</tt> class has the
       following method that you need to implement:</p>
    
    <!-- copied from src tree since we don't expose com.sun classes in the
         javadoc distributed with the JWSDP -->
         
    <pre class="code"><xmp>
public abstract class NamespacePrefixMapper {

    private static final String[] EMPTY_STRING = new String[0];

    /**
     * Returns a preferred prefix for the given namespace URI.
     * 
     * This method is intended to be overrided by a derived class.
     * 
     * @param namespaceUri
     *      The namespace URI for which the prefix needs to be found.
     *      Never be null. "" is used to denote the default namespace.
     * @param suggestion
     *      When the content tree has a suggestion for the prefix
     *      to the given namespaceUri, that suggestion is passed as a
     *      parameter. Typicall this value comes from the QName.getPrefix
     *      to show the preference of the content tree. This parameter
     *      may be null, and this parameter may represent an already
     *      occupied prefix. 
     * @param requirePrefix
     *      If this method is expected to return non-empty prefix.
     *      When this flag is true, it means that the given namespace URI
     *      cannot be set as the default namespace.
     * 
     * @return
     *      null if there's no prefered prefix for the namespace URI.
     *      In this case, the system will generate a prefix for you.
     * 
     *      Otherwise the system will try to use the returned prefix,
     *      but generally there's no guarantee if the prefix will be
     *      actually used or not.
     * 
     *      return "" to map this namespace URI to the default namespace.
     *      Again, there's no guarantee that this preference will be
     *      honored.
     * 
     *      If this method returns "" when requirePrefix=true, the return
     *      value will be ignored and the system will generate one.
     * 
     * @since JAXB 1.0.1
     */
    public abstract String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix);

    /**
     * Returns a list of namespace URIs that should be declared
     * at the root element.
     *
     * <p>
     * By default, the JAXB RI 1.0.x produces namespace declarations only when
     * they are necessary, only at where they are used. Because of this
     * lack of look-ahead, sometimes the marshaller produces a lot of
     * namespace declarations that look redundant to human eyes. For example,
     * <pre><xmp>
     * <?xml version="1.0"?>
     * <root>
     *   <ns1:child xmlns:ns1="urn:foo"> ... </ns1:child>
     *   <ns2:child xmlns:ns2="urn:foo"> ... </ns2:child>
     *   <ns3:child xmlns:ns3="urn:foo"> ... </ns3:child>
     *   ...
     * </root>
     * <xmp></pre>
     *
     * <p>
     * The JAXB RI 2.x mostly doesn't exhibit this behavior any more,
     * as it declares all statically known namespace URIs (those URIs
     * that are used as element/attribute names in JAXB annotations),
     * but it may still declare additional namespaces in the middle of
     * a document, for example when (i) a QName as an attribute/element value
     * requires a new namespace URI, or (ii) DOM nodes as a portion of an object
     * tree requires a new namespace URI.
     *
     * <p>
     * If you know in advance that you are going to use a certain set of
     * namespace URIs, you can override this method and have the marshaller
     * declare those namespace URIs at the root element.
     *
     * <p>
     * For example, by returning <code>new String[]{"urn:foo"}</code>,
     * the marshaller will produce:
     * <pre><xmp>
     * <?xml version="1.0"?>
     * <root xmlns:ns1="urn:foo">
     *   <ns1:child> ... </ns1:child>
     *   <ns1:child> ... </ns1:child>
     *   <ns1:child> ... </ns1:child>
     *   ...
     * </root>
     * <xmp></pre>
     * <p>
     * To control prefixes assigned to those namespace URIs, use the
     * {@link #getPreferredPrefix(String, String, boolean)} method. 
     * 
     * @return
     *      A list of namespace URIs as an array of {@link String}s.
     *      This method can return a length-zero array but not null.
     *      None of the array component can be null. To represent
     *      the empty namespace, use the empty string <code>""</code>.
     * 
     * @since
     *      JAXB RI 1.0.2 
     */
    public String[] getPreDeclaredNamespaceUris() {
        return EMPTY_STRING;
    }

    /**
     * Similar to {@link #getPreDeclaredNamespaceUris()} but allows the
     * (prefix,nsUri) pairs to be returned.
     *
     * <p>
     * With {@link #getPreDeclaredNamespaceUris()}, applications who wish to control
     * the prefixes as well as the namespaces needed to implement both
     * {@link #getPreDeclaredNamespaceUris()} and {@link #getPreferredPrefix(String, String, boolean)}.
     *
     * <p>
     * This version eliminates the needs by returning an array of pairs.
     *
     * @return
     *      always return a non-null (but possibly empty) array. The array stores
     *      data like (prefix1,nsUri1,prefix2,nsUri2,...) Use an empty string to represent
     *      the empty namespace URI and the default prefix. Null is not allowed as a value
     *      in the array.
     *
     * @since
     *      JAXB RI 2.0 beta
     */
    public String[] getPreDeclaredNamespaceUris2() {
        return EMPTY_STRING;
    }

    /**
     * Returns a list of (prefix,namespace URI) pairs that represents
     * namespace bindings available on ancestor elements (that need not be repeated
     * by the JAXB RI.)
     *
     * <p>
     * Sometimes JAXB is used to marshal an XML document, which will be
     * used as a subtree of a bigger document. When this happens, it's nice
     * for a JAXB marshaller to be able to use in-scope namespace bindings
     * of the larger document and avoid declaring redundant namespace URIs.
     *
     * <p>
     * This is automatically done when you are marshalling to {@link XMLStreamWriter},
     * {@link XMLEventWriter}, {@link DOMResult}, or {@link Node}, because
     * those output format allows us to inspect what's currently available
     * as in-scope namespace binding. However, with other output format,
     * such as {@link OutputStream}, the JAXB RI cannot do this automatically.
     * That's when this method comes into play.
     *
     * <p>
     * Namespace bindings returned by this method will be used by the JAXB RI,
     * but will not be re-declared. They are assumed to be available when you insert
     * this subtree into a bigger document.
     *
     * <p>
     * It is <b>NOT</b> OK to return  the same binding, or give
     * the receiver a conflicting binding information.
     * It's a responsibility of the caller to make sure that this doesn't happen
     * even if the ancestor elements look like:
     * <pre><xmp>
     *   <foo:abc xmlns:foo="abc">
     *     <foo:abc xmlns:foo="def">
     *       <foo:abc xmlns:foo="abc">
     *         ... JAXB marshalling into here.
     *       </foo:abc>
     *     </foo:abc>
     *   </foo:abc>
     * </xmp></pre>
     * <!-- TODO: shall we relax this constraint? -->
     *
     * @return
     *      always return a non-null (but possibly empty) array. The array stores
     *      data like (prefix1,nsUri1,prefix2,nsUri2,...) Use an empty string to represent
     *      the empty namespace URI and the default prefix. Null is not allowed as a value
     *      in the array.
     *
     * @since JAXB RI 2.0 beta
     */
    public String[] getContextualNamespaceDecls() {
        return EMPTY_STRING;
    }
}
</xmp></pre>

    <p>See the <a href="samples.html">namespace-prefix</a> sample application
       for a detailed example.</p>
  

    <a name="indent"></a>
    <h3>Indentation</h3>
  
    <table class=property summary="">
  	  <tr><td>
  	  	<b>Property name:</b>
  	  </td><td>
  		<tt>com.sun.xml.bind.indentString</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Type:</b>
  	  </td><td>
  		<tt>java.lang.String</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Default value:</b>
  	  </td><td>
  		"&nbsp;&nbsp;&nbsp;&nbsp;" (four whitespaces)
  	  </td></tr>
    </table>
  
    <p>This property controls the string used for the indentation of XML. An element 
    of depth <i>k</i> will be indented by printing this string <i>k</i> times. Note 
    that the "<code>jaxb.formatted.output</code>" property needs to be set to "true" 
    for the formatting/indentation of the output to occur. See the API documentation for 
    <a href="../../doc/api/javax/xml/bind/Marshaller.html"><code>
    javax.xml.bind.Marshaller</code></a> interface for details of this property.</p>
  
  
  
    <a name="charescape"></a>
    <h3>Character Escaping Control</h3>
  
    <table class=property summary="">
  	  <tr><td>
  		<b>Property name:</b>
  	  </td><td>
  		<tt>com.sun.xml.bind.characterEscapeHandler</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Type:</b>
  	  </td><td>
  		<tt>com.sun.xml.bind.marshaller.CharacterEscapeHandler</tt>
  	  </td></tr>
  	  <tr><td>
  		<b>Default value:</b>
  	  </td><td>
  		null
  	  </td></tr>
    </table>
  
    <p>
  	By default, the marshaller implementation of the JAXB RI tries to escape 
  	characters so they can be safely represented in the output encoding 
  	(by using Unicode numeric character references of the form &amp;#dddd;)
    </p><p>
  	Unfortunately, due to various technical reasons, the default behavior 
  	may not meet your expectations. If you need to handle escaping more 
  	adroitly than the default manner, you can do so by doing the following:
  	<ol>
  	<li>Write a class that implements the 
  	    <code>com.sun.xml.bind.marshaller.CharacterEscapeHandler</code> 
  	    interface.</li> 
  	<li>Create a new instance of it.</li>
  	<li>Set that instance to the Marshaller by using this property.</li>
  	</ol>
    </p><p>
  	See the <a href="samples.html">character-escape</a> sample application 
  	for more details.
    </p>
  
  
  
    <a name="xmldecl"></a>
    <h3>XML Declaration Control</h3> 
  
    <table class=property summary="">
      <tr><td>
        <b>Property name:</b>
      </td><td>
        <tt>com.sun.xml.bind.xmlDeclaration</tt>
      </td></tr>
      <tr><td>
        <b>Type:</b>
      </td><td>
        <tt>boolean</tt>
      </td></tr>
      <tr><td>
        <b>Default value:</b>
      </td><td>
        true
      </td></tr>
    </table>
  
		<p> This experimental JAXB RI 1.0.x property has been adopted as a standard in JAXB 2.0.  The 2.0 RI will
		    continue to support this property, but client code should be using the <a href="api/Marshaller.html#JAXB_FRAGMENT">
		    Marshaller.JAXB_FRAGMENT</a> property instead.  Please refer to the <a href="api/Marshaller.html#supportedProps">Marshaller
		    javadoc</a> for a complete description of the behavior.

        <p> In JAXB 2.0, calling:
        <pre class=code>marshaller.setProperty("com.sun.xml.bind.xmlDeclaration", true);</pre>
            is equivalent to calling:
        <pre class=code>marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);</pre>

        <p> JAXB 1.0 generated code and clients will continue to work exactly the same on the JAXB 2.0 runtime as
            they did on the JAXB 1.0 runtime.
		<p> Enabling fragment marshalling could be useful if you are inserting the output of the XML into another XML.



    <a name="xmlheader"></a>
    <h3>XML Preamble Control</h3> 
  
    <table class=property summary="">
      <tr><td>
        <b>Property name:</b>
      </td><td>
        <tt>com.sun.xml.bind.xmlHeaders</tt>
      </td></tr>
      <tr><td>
        <b>Type:</b>
      </td><td>
        <tt>java.lang.String</tt>
      </td></tr>
      <tr><td>
        <b>Default value:</b>
      </td><td>
        null
      </td></tr>
    </table>
    
    <p>
    	This property allows you to specify an XML preamble (&lt;?xml ...> declaration) and any additional PIs, comments, DOCTYPE declaration that follows it. This property takes effect only when you are marshalling to <tt>OutputStream</tt>, <tt>Writer</tt>, or <tt>StreamResult</tt>.
    
    
    
    <!-- TODO: talk about c14n when it's considered stable -->
    
    <hr/>
    <div class=footer>
      $Revision: 1.4 $<br/>
      $Date: 2006-03-14 17:45:33 $
    </div>
  </body>
</html>
  